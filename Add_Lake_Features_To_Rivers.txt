River System Structure Analysis
Based on my examination of the codebase, here's the detailed structure of river paths and how to work with them for feature placement:
1. River Data Structure
Each river is stored as a Dictionary with the following structure:
{
    "points": PackedVector3Array,  # Array of 3D points along the river path
    "width0": float,              # Width at the source (typically 10.0-16.0)
    "width1": float               # Width at the mouth (typically 34.0-58.0)
}
Key Details about points:
- Points are Vector3 objects where x and z represent world coordinates, y is typically 0.0
- Points are generated by downsampling the path cells with a stride of 3 (every 3rd cell)
- Points flow from source (mountains) to mouth (sea)
- Minimum of 24 points required for a valid river
- Rivers terminate when they reach sea_level + 0.5 height
2. River Width Interpolation
River width varies along the path using a power-based interpolation:
# Parameter t goes from 0.0 (source) to 1.0 (mouth)
var t: float = float(i) / float(max(1, points.size() - 1))
var width: float = lerp(width0, width1, pow(t, 0.85))
Characteristics:
- Width increases non-linearly from source to mouth
- The pow(t, 0.85) creates a curve that's initially narrow then widens more rapidly near the mouth
- Additional random variation (±1.0) is added during terrain carving
- Carved width is always at least 4.0 units
3. River Flow Direction
Flow Detection:
- Rivers flow from higher elevation to lower elevation (downhill tracing)
- The first point in the points array is the source (highest point)
- The last point is the mouth (where it reaches sea level)
- Flow direction can be determined by iterating from index 0 to points.size() - 1
River Termination:
- Rivers stop when height <= sea_level + 0.5
- This creates natural river mouths that connect to the ocean
4. River Point Sampling and Parameterization
Parameterization:
# Get position at parameter t (0.0 to 1.0)
func get_river_position_at(river_points: PackedVector3Array, t: float) -> Vector3:
    if river_points.size() < 2:
        return Vector3.ZERO
    
    var index_float: float = t * float(river_points.size() - 1)
    var index: int = int(index_float)
    var fraction: float = index_float - float(index)
    
    if index >= river_points.size() - 1:
        return river_points[river_points.size() - 1]
    
    return river_points[index].lerp(river_points[index + 1], fraction)
Direction at Point:
func get_river_direction_at(river_points: PackedVector3Array, t: float) -> Vector3:
    var index_float: float = t * float(river_points.size() - 1)
    var index: int = int(index_float)
    
    var prev_idx: int = max(0, index - 1)
    var next_idx: int = min(river_points.size() - 1, index + 1)
    
    var dir: Vector3 = river_points[next_idx] - river_points[prev_idx]
    dir.y = 0.0  # Keep horizontal
    return dir.normalized()
5. Width at Any Point
func get_river_width_at(river: Dictionary, t: float) -> float:
    var width0: float = river.get("width0", 12.0)
    var width1: float = river.get("width1", 44.0)
    return lerp(width0, width1, pow(t, 0.85))
6. River Classification Logic
Current State: There is no existing river classification or segmentation system. Rivers are treated as uniform paths from source to mouth.
Potential Classification Criteria:
- By position: Upper (t < 0.3), Middle (0.3 ≤ t ≤ 0.7), Lower (t > 0.7)
- By width: Narrow (< 20), Medium (20-35), Wide (> 35)
- By gradient: Could be calculated from height differences between points
7. River-Terrain Interaction
Carving Process:
- Rivers carve channels into the terrain using a smoothstep profile
- Channel depth increases from 4.0 units at source to 14.0 units at mouth
- Carving radius is 115% of the river width with smooth edges
- The carved height never goes below sea_level - 0.75
Ground Height Sampling:
- Rivers use _ground_height(x, z) to sample terrain at any point
- This is essential for placing features at the correct vertical position
8. Feature Placement Recommendations
Suitable Locations for Features:
1. River Mouths (t > 0.9):
   - Wide, slow-flowing water
   - Good for: Docks, harbors, marinas, bridges
2. Middle Sections (0.3 < t < 0.7):
   - Moderate width and flow
   - Good for: Bridges, ferries, riverside buildings
3. Upper Sections (t < 0.3):
   - Narrow, fast-flowing
   - Good for: Small bridges, waterfalls (if terrain permits)
Feature Placement Utilities:
# Find riverside position with offset perpendicular to flow
func get_riverside_position(river_points: PackedVector3Array, t: float, side_offset: float) -> Vector3:
    var center_pos: Vector3 = get_river_position_at(river_points, t)
    var direction: Vector3 = get_river_direction_at(river_points, t)
    var perpendicular: Vector3 = direction.cross(Vector3.UP).normalized()
    
    return center_pos + perpendicular * side_offset
# Check if position is suitable for feature (flat enough, etc.)
func is_suitable_for_feature(pos: Vector3, required_radius: float) -> bool:
    var center_height: float = _terrain.get_height_at(pos.x, pos.z)
    
    # Check flatness in radius
    for angle in range(0, 360, 45):
        var check_pos: Vector3 = pos + Vector3(
            cos(deg_to_rad(angle)) * required_radius,
            0.0,
            sin(deg_to_rad(angle)) * required_radius
        )
        var check_height: float = _terrain.get_height_at(check_pos.x, check_pos.z)
        
        if abs(check_height - center_height) > 2.0:  # Too steep
            return false
    
    return true
9. Accessing River Data
From World Context:
# Rivers are available in world context
var rivers: Array = world_ctx.rivers
# Iterate through rivers
for river in rivers:
    var points: PackedVector3Array = river.get("points", PackedVector3Array())
    var width0: float = river.get("width0", 12.0)
    var width1: float = river.get("width1", 44.0)
From Terrain Generator:
# If you have access to the terrain generator
var rivers: Array = terrain_generator.get_rivers()  # You may need to add this getter
This structure provides a solid foundation for placing water features along rivers with proper parameterization, width interpolation, and flow direction detection. The lack of existing classification means you'll need to implement your own logic for determining suitable feature locations based on the criteria I've outlined.