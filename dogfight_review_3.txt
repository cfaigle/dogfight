1) Current status in this codebase
A) “Upgrade the graphics engine to be much more performant”

What you already have (good):

Solid batching strategy: heavy use of MultiMesh for forests and many props, plus a manual prop LOD system.

Terrain is chunked and has LOD meshes (3 per chunk), so the “big obvious” terrain perf traps are mostly avoided.

What’s currently holding performance back (actionable):

Double AA cost: project settings are using MSAA + FXAA at the same time (both enabled). One of your other reviews called this out directly. 

dogfight_review_2

Extreme camera depth range: near=0.05 and far=90000 (review2 also spotted this). 

dogfight_review_2


This mostly hurts depth precision (z-fighting), and can make other tuning harder. It’s an easy win to set sane defaults.

Procedural terrain shader cost: terrain_ww2.gdshader does FBM noise multiple times per pixel; at higher resolutions or when fill-rate bound, this is a real cost.

Shadows are enabled at the sun, and you don’t globally disable shadows (only water/rivers disable casting). So “no shadows on most objects” from review1 is likely inaccurate. 

dogfight_review_1

B) “Make much better designed buildings and features”

Current reality:

Buildings are largely primitive-based (boxes + simple roof meshes), with some variety but still “samey.”

Materials are mostly flat colors / vertex color vibes, so silhouettes do most of the work and details don’t read.

Structural limitation:

You can’t get a big leap in perceived quality without either:

a texture/atlas/material system that works with instancing, or

curated mesh kits (external or handmade) that still batch well.

Review2’s direction (more architectural parameters + style systems) is the right idea, but it’s presented as pseudo-systems without anchoring to your actual generator/LOD/multimesh structure. 

dogfight_review_2

C) “Be able to use external textures and objects (fetch_assets + manifest.json)”

What works today:

There is a real bridge: scripts/util/asset_library.gd loads res://assets/external/manifest.json and exposes get_mesh_variants(key).

main.gd already tries to use external meshes for:

settlement buildings via "euro_buildings"

beach shacks via "beach_shacks"

What’s broken / incomplete:

Your repo’s assets/external/manifest.json is basically a stub: variant arrays are empty, so external assets never actually appear.

Schema/key mismatch: tools/fetch_assets.py currently writes different variant keys than the game requests (review2 explicitly identified “key mismatches”). 

dogfight_review_2


So even if you run the fetcher, it won’t reliably populate the keys main.gd asks for unless you fix it.

Textures are downloaded, but there’s no runtime texture/material integration yet (AssetLibrary only loads meshes, not texture sets).

2) What the two other AI reviews got right/wrong
Review 1 (summary)

Useful:

Correctly notices the project uses MSAA 2x + FXAA and suggests performance work first. 

dogfight_review_1

Correctly frames the external asset system as “underutilized” with an empty manifest, and recommends activating it. 

dogfight_review_1

Misleading / off-target:

“Implement PBR material system” is muddled: StandardMaterial3D is already PBR in Godot; what you actually need is texture/material workflows and batching, not “switch to PBR.” 

dogfight_review_1

“No shadows on most objects” doesn’t match your code patterns (you only disable shadows on water/rivers). 

dogfight_review_1

Suggesting custom frustum/occlusion culling as Phase 1 is less ROI than fixing AA/camera depth + instancing/material choices.

Review 2 (summary)

Best hits:

Spots the real quick wins: double AA + camera near/far extremes. 

dogfight_review_2

Nails the core external asset problem: the manifest keys don’t match what the game expects. 

dogfight_review_2

Needs correction to be implementable:

It overpromises on perf gain (“30–50%”) and uses slightly sloppy setting names/snippets. 

dogfight_review_2

It proposes adding “materials variants” but your current AssetLibrary only returns meshes, and your MultiMesh path naturally wants mesh-with-its-materials (or a shared override), not a separate per-instance material list. 

dogfight_review_2

3) Final workable recommendation (phased, “another AI can implement this”)
Phase 0 — Baseline + guardrails (1 small PR)

Goal: measure and avoid regressions.

Add a tiny on-screen debug panel (FPS, draw calls, instances, triangles).

Add a “quality preset” enum in settings (Low/Med/High) and apply it on boot.

Definition of done: you can toggle presets live and see FPS + draw call changes.

Phase 1 — Immediate perf wins + correctness (high ROI)

1) Remove double AA

Pick one:

FXAA only (fastest), OR

MSAA 2x only (cleaner edges, more cost)

Update project settings accordingly (you currently have both).

2) Fix camera near/far sanely

Set near to something like 0.3–1.0

Set far to something like terrain_size * 1.1 (or a fixed 20k if your world is ~18k)

3) Shadows: cap distance

Keep shadows, but limit directional shadow distance to what matters (dogfight gameplay does not need 10km shadows).

4) Terrain shader “cheap mode”

Add a shader uniform quality_level:

low: fewer FBM octaves, less “town speckle”

high: current look

Definition of done: on the same scene seed, Low preset is visibly simpler and materially faster.

Phase 2 — Make external objects actually show up (fix the manifest pipeline)

This is the “unlock visuals fast” step both reviews point toward, but you must fix the key mismatch. 

dogfight_review_2

2.1 Align fetch_assets.py output to what the game asks for

In write_manifest() / build_variant_pools() change keys to match main.gd usage:

euro_buildings

industrial_buildings (even if you don’t use it yet, keep it consistent)

beach_shacks

trees_conifer, trees_broadleaf, trees_palm (future-proof)

Right now the script writes keys like euro_building_mesh / beach_shack_mesh (wrong for the game). That’s the central bug.

2.2 Make manifest “append-only safe”

Keep your existing manifest schema stable:

use_external_assets

variants: { key: [res://…] }

It’s fine to add extra metadata fields, but don’t rename what runtime reads.

2.3 Connect industrial + trees

In main.gd:

When generating industrial areas, try _assets.get_mesh_variants("industrial_buildings") first, else fall back to procedural.

For forests, optionally add a mode: if tree variants exist, use external tree meshes in MultiMesh; otherwise use current procedural.

Definition of done: after running tools/fetch_assets.py, flipping “use external assets” actually changes the world (buildings/shacks at minimum).

Phase 3 — External textures without killing batching (the “real” visual upgrade)

This is where most projects accidentally destroy performance, so the rule is: few materials, many instances.

3.1 Add a small TextureSet manifest
Extend manifest.json with something like:

"textures": {
  "building_atlas_1": {
    "albedo": "res://assets/external/textures/…",
    "normal": "res://assets/external/textures/…",
    "orm": "res://assets/external/textures/…"
  }
}


Review2 suggested adding texture loading support; do it, but keep AssetLibrary simple. 

dogfight_review_2

3.2 Create 1–2 atlased materials for procedural buildings

One “plaster/brick/roof” atlas for towns/cities

One “metal/concrete” atlas for industrial

Use vertex colors as variation multipliers (tint/age/grime) while keeping the same material.

3.3 Terrain: texture blend (optional but huge visually)

Replace some procedural color with texture blending by slope/height:

grass texture + rock texture + sand texture

keep the procedural “field grid” as a subtle macro overlay

Definition of done: buildings/terrain gain texture detail but draw calls don’t explode.

Phase 4 — “Much better designed buildings & features” (quality + system design)

Now that you can swap in meshes and textures safely:

4.1 Split “building generation” into a real kit system
Implement a BuildingKit concept:

A kit = { base_meshes[], roof_meshes[], prop_meshes[], material }

Each settlement style picks a kit (city/town/hamlet/coastal/industrial)

4.2 Add silhouette variety first (cheap, high impact)

L/T/U footprints (not just rectangles)

Step-backs (2–3 stacked volumes)

Roof families: gable/hip/mansard/sawtooth (industrial)

(Review2’s “roof systems” idea is right; implement it as kit-driven mesh composition rather than a whole new architecture DSL.) 

dogfight_review_2

4.3 Add “feature clusters”
Instead of individual props sprinkled randomly:

Farm cluster: barn + silo + fences + field edge props

Industrial cluster: warehouse + tanks + pipes + yard

Coastal cluster: shacks + docks + boats + nets

Definition of done: the world reads as designed “places,” not scattered primitives.

The shortest path to “works and looks way better”

If you do only three things, do these in order:

Fix AA + camera near/far (fast win). 

dogfight_review_2

Fix fetch_assets → manifest key mismatch so external meshes actually appear. 

dogfight_review_2

Add 1–2 atlased materials and drive variation via vertex colors (keeps batching).

If you want, I can produce a concrete patch plan (exact edits) for:

tools/fetch_assets.py (key fixes + optional texture entries)

scripts/util/asset_library.gd (texture loading extension)

scripts/game/main.gd (industrial + tree external variants + quality presets)
