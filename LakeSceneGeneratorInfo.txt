ðŸ—ï¸ Comprehensive Plan: Lake Scene Generator System
Based on my analysis of the existing world generation architecture, here's my detailed plan for implementing sophisticated lake scenes with boats, buoys, docks, harbors, beaches, and other waterfront features.
ðŸ“‹ System Architecture Overview
Current System Strengths
- Modular component pipeline with priority-based execution
- Data-driven parameter system with .tres resource files
- Deterministic generation with shared RNG and seed system
- Efficient caching for meshes, materials, and props
- Layer-based organization for clean scene structure
- Existing water bodies generation to build upon
Integration Strategy
The lake scene system will extend the existing LakesComponent and add new specialized components for detailed waterfront scene generation. This leverages the established patterns while adding comprehensive lake functionality.
ðŸŽ¯ Phase 1: Core Lake Scene Infrastructure
1.1 Create Lake Scene Resource Definitions
File: scripts/resources/lake_defs.gd
extends Resource
@export var lake_types: Dictionary
@export var boat_types: Dictionary  
@export var buoy_types: Dictionary
@export var dock_types: Dictionary
@export var shore_features: Dictionary
File: resources/defs/lake_defs.tres
lake_types = {
    "basic": {"probability": 0.4, "shore_detail": false},
    "recreational": {"probability": 0.3, "shore_detail": true, "boats": true},
    "fishing": {"probability": 0.2, "shore_detail": true, "docks": true},
    "harbor": {"probability": 0.1, "shore_detail": true, "docks": true, "boats": true}
}
boat_types = {
    "fishing": {"mesh_size": Vector3(8, 3, 18), "color": Color(0.3, 0.2, 0.1)},
    "sailboat": {"mesh_size": Vector3(4, 8, 12), "color": Color(0.9, 0.9, 0.9)},
    "speedboat": {"mesh_size": Vector3(6, 2, 14), "color": Color(0.8, 0.2, 0.1)},
    "pontoon": {"mesh_size": Vector3(10, 2, 20), "color": Color(0.7, 0.7, 0.7)}
}
buoy_types = {
    "navigation": {"radius": 0.8, "height": 2.4, "color": Color(1.0, 0.8, 0.0)},
    "marker": {"radius": 0.5, "height": 1.8, "color": Color(0.8, 0.8, 0.8)},
    "racing": {"radius": 0.6, "height": 2.0, "color": Color(1.0, 0.0, 0.0)}
}
dock_types = {
    "fishing_pier": {"length": 25.0, "width": 3.0, "has_shed": true},
    "boat_launch": {"length": 15.0, "width": 8.0, "has_ramp": true},
    "marina_dock": {"length": 40.0, "width": 4.0, "has_posts": true},
    "swimming_dock": {"length": 12.0, "width": 2.5, "has_ladder": true}
}
shore_features = {
    "beach": {"width_min": 8.0, "width_max": 25.0, "sand_color": Color(0.9, 0.8, 0.6)},
    "concession": {"size": Vector2(12, 8), "has_umbrella": true},
    "picnic_area": {"table_count": 4, "tree_shade": true}
}
1.2 Enhanced LakesComponent
Key Changes to scripts/world/components/builtin/lakes_component.gd:
func get_optional_params() -> Dictionary:
    return {
        # Existing basic params
        "lake_count": 8,
        "lake_min_radius": 160.0,
        "lake_max_radius": 520.0,
        
        # New scene generation params
        "lake_scene_probability": 0.6,  # 60% get detailed scenes
        "lake_types_resource": "res://resources/defs/lake_defs.tres",
        "boat_density": 0.3,           # boats per lake on average
        "buoy_density": 2.5,           # buoys per lake radius unit
        "dock_probability": 0.4,       # probability of docks at lakes
        "shore_detail_probability": 0.7, # probability of shore features
        "beach_probability": 0.3,      # probability of beach areas
    }
func generate(world_root: Node3D, params: Dictionary, rng: RandomNumberGenerator) -> void:
    # ... existing heightmap modification code ...
    
    var lakes = ctx.water_bodies_generator.carve_lakes_with_scenes(ctx, params, rng)
    ctx.lakes = lakes
    
    # Update terrain generator
    ctx.terrain_generator.set_heightmap_data(ctx.hmap, ctx.hmap_res, ctx.hmap_step, ctx.hmap_half)
    
    # Generate lake scenes
    var lake_scenes_root = ctx.get_layer("LakeScenes")
    var lake_generator = LakeSceneFactory.new()
    
    for lake_data in lakes:
        var lake_scene = lake_generator.generate_lake_scene(ctx, lake_data, lake_scenes_root, rng, params)
        if lake_scene != null:
            lake_data["scene_root"] = lake_scene
ðŸŽ¯ Phase 2: Lake Scene Generation Framework
2.1 Lake Scene Factory
File: scripts/world/generators/lake_scene_factory.gd
class_name LakeSceneFactory
extends RefCounted
var _lake_defs: Resource = null
var _boat_generator: BoatGenerator = null
var _dock_generator: DockGenerator = null
var _shore_generator: ShoreFeatureGenerator = null
func _init():
    _lake_defs = load("res://resources/defs/lake_defs.tres")
    _boat_generator = BoatGenerator.new()
    _dock_generator = DockGenerator.new()
    _shore_generator = ShoreFeatureGenerator.new()
func generate_lake_scene(ctx: WorldContext, lake_data: Dictionary, parent: Node3D, rng: RandomNumberGenerator, params: Dictionary) -> Node3D:
    var scene_root = Node3D.new()
    scene_root.name = "LakeScene_%d" % ctx.seed
    
    var scene_type = _determine_scene_type(lake_data, params, rng)
    lake_data["scene_type"] = scene_type
    
    # Generate water mesh (enhanced)
    _generate_lake_water(scene_root, lake_data, scene_type, rng)
    
    # Generate shore features
    if _should_have_shore_detail(scene_type, params, rng):
        _shore_generator.generate_shore_features(ctx, scene_root, lake_data, rng)
    
    # Generate docks/harbors
    if _should_have_docks(scene_type, params, rng):
        _dock_generator.generate_docks(ctx, scene_root, lake_data, rng)
    
    # Generate boats and buoys
    if _should_have_boats(scene_type, params, rng):
        _boat_generator.generate_boats_and_buoys(ctx, scene_root, lake_data, rng)
    
    parent.add_child(scene_root)
    return scene_root
func _determine_scene_type(lake_data: Dictionary, params: Dictionary, rng: RandomNumberGenerator) -> String:
    var lake_types = _lake_defs.lake_types
    
    # Weighted random selection
    var types = lake_types.keys()
    var weights = []
    for type in types:
        weights.append(lake_types[type].probability)
    
    var total_weight = 0.0
    for w in weights:
        total_weight += w
    
    var roll = rng.randf() * total_weight
    var current_weight = 0.0
    
    for i in range(types.size()):
        current_weight += weights[i]
        if roll <= current_weight:
            return types[i]
    
    return "basic"
2.2 Boat Generator
File: scripts/world/generators/boat_generator.gd
class_name BoatGenerator  
extends RefCounted
func generate_boats_and_buoys(ctx: WorldContext, scene_root: Node3D, lake_data: Dictionary, rng: RandomNumberGenerator) -> void:
    var lake_center = lake_data.center
    var lake_radius = lake_data.radius
    var lake_defs = load("res://resources/defs/lake_defs.tres")
    
    # Generate boats
    var boat_count = rng.randi_range(1, int(lake_radius / 50.0))
    for i in range(boat_count):
        var boat_type = _select_boat_type(lake_data, rng)
        var boat_pos = _generate_boat_position(lake_center, lake_radius, rng)
        var boat = _create_boat_mesh(boat_type, boat_pos, rng)
        scene_root.add_child(boat)
    
    # Generate buoys
    var buoy_count = int(lake_radius / 30.0)
    for i in range(buoy_count):
        var buoy_type = rng.randf() < 0.7 ? "navigation" : "marker"
        var buoy_pos = _generate_buoy_position(lake_center, lake_radius, rng)
        var buoy = _create_buoy_mesh(buoy_type, buoy_pos, rng)
        scene_root.add_child(buoy)
func _create_boat_mesh(boat_type: String, position: Vector3, rng: RandomNumberGenerator) -> Node3D:
    var boat_root = Node3D.new()
    boat_root.position = position
    boat_root.name = "Boat_" + boat_type
    
    var lake_defs = load("res://resources/defs/lake_defs.tres")
    var boat_config = lake_defs.boat_types[boat_type]
    
    # Main hull
    var hull_mesh = BoxMesh.new()
    hull_mesh.size = boat_config.mesh_size
    
    var hull_instance = MeshInstance3D.new()
    hull_instance.mesh = hull_mesh
    hull_instance.material_override = _create_boat_material(boat_config.color)
    
    boat_root.add_child(hull_instance)
    
    # Add boat-specific features
    match boat_type:
        "sailboat":
            _add_sail_mast(boat_root, rng)
        "fishing":
            _add_fishing_equipment(boat_root, rng)
        "speedboat":
            _add_windshield(boat_root, rng)
        "pontoon":
            _add_pontoon_tubes(boat_root, boat_config, rng)
    
    return boat_root
func _add_sail_mast(boat_root: Node3D, rng: RandomNumberGenerator) -> void:
    var mast = BoxMesh.new()
    mast.size = Vector3(0.2, 12.0, 0.2)
    
    var mast_instance = MeshInstance3D.new()
    mast_instance.mesh = mast
    mast_instance.position = Vector3(0, 6.0, 0)
    mast_instance.material_override = _create_wood_material()
    
    boat_root.add_child(mast_instance)
    
    # Sail
    var sail_mesh = PrismMesh.new()
    sail_mesh.size = Vector3(8.0, 10.0, 0.1)
    sail_mesh.subdivide_width = 3
    sail_mesh.subdivide_depth = 3
    
    var sail_instance = MeshInstance3D.new()
    sail_instance.mesh = sail_mesh
    sail_instance.position = Vector3(2.0, 5.0, 0)
    sail_instance.material_override = _create_sail_material()
    
    boat_root.add_child(sail_instance)
ðŸŽ¯ **
ðŸŽ¯ Phase 3: Dock and Shore Feature Systems
3.1 Dock Generator
File: scripts/world/generators/dock_generator.gd
class_name DockGenerator
extends RefCounted
func generate_docks(ctx: WorldContext, scene_root: Node3D, lake_data: Dictionary, rng: RandomNumberGenerator) -> void:
    var lake_center = lake_data.center
    var lake_radius = lake_data.radius
    var lake_defs = load("res://resources/defs/lake_defs.tres")
    
    # Find suitable shore points for docks
    var shore_points = _find_shore_points(ctx, lake_center, lake_radius, rng)
    
    # Place docks based on lake size and type
    var dock_count = min(shore_points.size(), rng.randi_range(1, 3))
    
    for i in range(dock_count):
        if shore_points.is_empty():
            break
            
        var shore_point = shore_points.pop_at(rng.randi() % shore_points.size())
        var dock_type = _select_dock_type(lake_data, rng)
        var dock = _create_dock(dock_type, shore_point, lake_data, rng)
        scene_root.add_child(dock)
func _create_dock(dock_type: String, shore_point: Vector3, lake_data: Dictionary, rng: RandomNumberGenerator) -> Node3D:
    var dock_root = Node3D.new()
    dock_root.position = shore_point
    dock_root.name = "Dock_" + dock_type
    
    var lake_defs = load("res://resources/defs/lake_defs.tres")
    var dock_config = lake_defs.dock_types[dock_type]
    
    # Main dock structure
    var dock_mesh = BoxMesh.new()
    dock_mesh.size = Vector3(dock_config.length, 0.3, dock_config.width)
    
    var dock_instance = MeshInstance3D.new()
    dock_instance.mesh = dock_mesh
    dock_instance.material_override = _create_dock_material()
    
    dock_root.add_child(dock_instance)
    
    # Add dock-specific features
    match dock_type:
        "fishing_pier":
            if dock_config.has_shed:
                _add_fishing_shed(dock_root, dock_config, rng)
        "boat_launch":
            if dock_config.has_ramp:
                _add_boat_ramp(dock_root, dock_config, rng)
        "marina_dock":
            if dock_config.has_posts:
                _add_dock_posts(dock_root, dock_config, rng)
        "swimming_dock":
            if dock_config.has_ladder:
                _add_swimming_ladder(dock_root, dock_config, rng)
    
    return dock_root
func _add_fishing_shed(dock_root: Node3D, dock_config: Dictionary, rng: RandomNumberGenerator) -> void:
    var shed = BoxMesh.new()
    shed.size = Vector3(6.0, 3.5, 4.0)
    
    var shed_instance = MeshInstance3D.new()
    shed_instance.mesh = shed
    shed_instance.position = Vector3(dock_config.length * 0.3, 1.75, 0)
    shed_instance.material_override = _create_shed_material()
    
    dock_root.add_child(shed_instance)
    
    # Roof
    var roof_mesh = PrismMesh.new()
    roof_mesh.size = Vector3(7.0, 2.0, 5.0)
    
    var roof_instance = MeshInstance3D.new()
    roof_instance.mesh = roof_mesh
    roof_instance.position = Vector3(dock_config.length * 0.3, 4.5, 0)
    roof_instance.material_override = _create_roof_material()
    
    dock_root.add_child(roof_instance)
3.2 Shore Feature Generator
File: scripts/world/generators/shore_feature_generator.gd
class_name ShoreFeatureGenerator
extends RefCounted
func generate_shore_features(ctx: WorldContext, scene_root: Node3D, lake_data: Dictionary, rng: RandomNumberGenerator) -> void:
    var lake_center = lake_data.center
    var lake_radius = lake_data.radius
    var lake_defs = load("res://resources/defs/lake_defs.tres")
    
    # Sample shore points around the lake
    var shore_samples = _sample_shore_points(ctx, lake_center, lake_radius, 24, rng)
    
    for shore_point in shore_samples:
        var feature_type = _determine_shore_feature(lake_data, shore_point, rng)
        
        match feature_type:
            "beach":
                _create_beach_area(scene_root, shore_point, lake_data, rng)
            "concession":
                _create_concession_stand(scene_root, shore_point, rng)
            "picnic_area":
                _create_picnic_area(scene_root, shore_point, rng)
func _create_beach_area(scene_root: Node3D, shore_point: Vector3, lake_data: Dictionary, rng: RandomNumberGenerator) -> void:
    var lake_defs = load("res://resources/defs/lake_defs.tres")
    var beach_config = lake_defs.shore_features.beach
    
    var beach_width = rng.randf_range(beach_config.width_min, beach_config.width_max)
    var beach_length = rng.randf_range(15.0, 35.0)
    
    # Beach surface
    var beach_mesh = BoxMesh.new()
    beach_mesh.size = Vector3(beach_length, 0.1, beach_width)
    
    var beach_instance = MeshInstance3D.new()
    beach_instance.mesh = beach_mesh
    beach_instance.position = shore_point
    beach_instance.material_override = _create_sand_material(beach_config.sand_color)
    
    scene_root.add_child(beach_instance)
    
    # Beach accessories (towel areas, umbrellas)
    var accessory_count = rng.randi_range(2, 6)
    for i in range(accessory_count):
        var pos = shore_point + Vector3(
            rng.randf_range(-beach_length * 0.4, beach_length * 0.4),
            0.1,
            rng.randf_range(-beach_width * 0.3, beach_width * 0.3)
        )
        
        if rng.randf() < 0.6:
            _create_towel_area(scene_root, pos, rng)
        else:
            _create_beach_umbrella(scene_root, pos, rng)
func _create_beach_umbrella(parent: Node3D, position: Vector3, rng: RandomNumberGenerator) -> void:
    var umbrella_root = Node3D.new()
    umbrella_root.position = position
    umbrella_root.name = "BeachUmbrella"
    
    # Pole
    var pole_mesh = CylinderMesh.new()
    pole_mesh.height = 3.0
    pole_mesh.top_radius = 0.1
    pole_mesh.bottom_radius = 0.15
    
    var pole_instance = MeshInstance3D.new()
    pole_instance.mesh = pole_mesh
    pole_instance.position = Vector3(0, 1.5, 0)
    pole_instance.material_override = _create_metal_material()
    
    umbrella_root.add_child(pole_instance)
    
    # Canopy
    var canopy_mesh = CylinderMesh.new()
    canopy_mesh.height = 0.2
    canopy_mesh.top_radius = 2.5
    canopy_mesh.bottom_radius = 2.5
    canopy_mesh.radial_segments = 8
    
    var canopy_instance = MeshInstance3D.new()
    canopy_instance.mesh = canopy_mesh
    canopy_instance.position = Vector3(0, 3.0, 0)
    canopy_instance.material_override = _create_umbrella_canopy_material(rng)
    
    umbrella_root.add_child(canopy_instance)
    
    parent.add_child(umbrella_root)
func _create_concession_stand(scene_root: Node3D, shore_point: Vector3, rng: RandomNumberGenerator) -> void:
    var concession_root = Node3D.new()
    concession_root.position = shore_point
    concession_root.name = "ConcessionStand"
    
    var lake_defs = load("res://resources/defs/lake_defs.tres")
    var concession_config = lake_defs.shore_features.concession
    
    # Main building
    var building_mesh = BoxMesh.new()
    building_mesh.size = Vector3(concession_config.size.x, 3.0, concession_config.size.y)
    
    var building_instance = MeshInstance3D.new()
    building_instance.mesh = building_mesh
    building_instance.position = Vector3(0, 1.5, 0)
    building_instance.material_override = _create_concession_material()
    
    concession_root.add_child(building_instance)
    
    # Counter
    var counter_mesh = BoxMesh.new()
    counter_mesh.size = Vector3(concession_config.size.x * 0.8, 1.2, 1.0)
    
    var counter_instance = MeshInstance3D.new()
    counter_instance.mesh = counter_mesh
    counter_instance.position = Vector3(0, 0.6, concession_config.size.y * 0.4)
    counter_instance.material_override = _create_counter_material()
    
    concession_root.add_child(counter_instance)
    
    # Optional umbrella
    if concession_config.has_umbrella:
        var umbrella_pos = Vector3(concession_config.size.x * 0.3, 0, -concession_config.size.y * 0.3)
        _create_beach_umbrella(concession_root, umbrella_pos, rng)
    
    scene_root.add_child(concession_root)
ðŸŽ¯ Phase 4: Advanced Lake Features
4.1 Harbor System
File: scripts/world/generators/harbor_generator.gd
class_name HarborGenerator
extends RefCounted
func generate_harbor(ctx: WorldContext, scene_root: Node3D, lake_data: Dictionary, rng: RandomNumberGenerator) -> void:
    var harbor_root = Node3D.new()
    harbor_root.name = "Harbor"
    
    # Find suitable harbor location (calm water, good shore access)
    var harbor_location = _find_harbor_location(ctx, lake_data, rng)
    harbor_root.position = harbor_location
    
    # Harbor infrastructure
    _generate_breakwater(harbor_root, rng)
    _generate_harbor_docks(harbor_root, rng)
    _generate_harbor_buildings(harbor_root, rng)
    _generate_harbor_equipment(harbor_root, rng)
    
    scene_root.add_child(harbor_root)
func _generate_breakwater(parent: Node3D, rng: RandomNumberGenerator) -> void:
    # Main breakwater structure
    var breakwater_length = rng.randf_range(80.0, 120.0)
    var breakwater_width = rng.randf_range(8.0, 12.0)
    
    var segments = 8
    for i in range(segments):
        var segment_mesh = BoxMesh.new()
        segment_mesh.size = Vector3(breakwater_length / segments, 2.5, breakwater_width)
        
        var segment_instance = MeshInstance3D.new()
        segment_instance.mesh = segment_mesh
        segment_instance.position = Vector3(
            (i - segments/2 + 0.5) * breakwater_length / segments,
            1.25,
            -breakwater_width / 2
        )
        segment_instance.material_override = _create_breakwater_material()
        
        parent.add_child(segment_instance)
        
        # Add navigation lights
        if i % 3 == 0:
            _add_navigation_light(segment_instance, rng)
func _add_navigation_light(parent: MeshInstance3D, rng: RandomNumberGenerator) -> void:
    var light_base = MeshInstance3D.new()
    var base_mesh = CylinderMesh.new()
    base_mesh.height = 1.0
    base_mesh.top_radius = 0.2
    base_mesh.bottom_radius = 0.25
    light_base.mesh = base_mesh
    light_base.position = Vector3(0, 1.5, 0)
    light
_base.material_override = _create_metal_material()
    
    var light_bulb = OmniLight3D.new()
    light_bulb.position = Vector3(0, 2.2, 0)
    light_bulb.light_color = Color(1.0, 1.0, 0.0)
    light_bulb.light_energy = 2.0
    light_bulb.omni_range = 15.0
    
    parent.add_child(light_base)
    parent.add_child(light_bulb)
## ðŸŽ¯ **Phase 5: Performance Optimization & LOD**
### **5.1 LOD System for Lake Scenes**
**File: `scripts/world/components/builtin/lake_scenes_component.gd`**
```gdscript
extends WorldComponentBase
class_name LakeScenesComponent
func get_priority() -> int:
    return 35  # After terrain mesh, but before detailed props
func get_optional_params() -> Dictionary:
    return {
        "lake_scene_lod_distance": 500.0,
        "lake_scene_max_detail_distance": 200.0,
        "enable_lake_scene_occlusion": true,
    }
func generate(world_root: Node3D, params: Dictionary, rng: RandomNumberGenerator) -> void:
    if ctx.lakes.is_empty():
        return
    
    var lake_scenes_layer = ctx.get_layer("LakeScenes")
    var lod_root = Node3D.new()
    lod_root.name = "LakeScenes_LOD"
    lake_scenes_layer.add_child(lod_root)
    
    # Create LOD system for each lake
    for lake_data in ctx.lakes:
        if not lake_data.has("scene_root"):
            continue
            
        var lake_scene = lake_data.scene_root as Node3D
        _create_lake_scene_lod(lod_root, lake_scene, lake_data, params)
    
    ctx.prop_lod_groups.append_array(_prop_lod_groups)
func _create_lake_scene_lod(parent: Node3D, scene_root: Node3D, lake_data: Dictionary, params: Dictionary) -> void:
    var lod_group = []
    var lake_center = lake_data.center
    var lod_distance = params.get("lake_scene_lod_distance", 500.0)
    
    # High detail version (all objects)
    var high_detail = scene_root.duplicate()
    high_detail.name = lake_root.name + "_High"
    parent.add_child(high_detail)
    
    # Medium detail version (no small props, simplified boats)
    var medium_detail = _create_medium_detail_lake(scene_root, lake_data)
    medium_detail.name = lake_root.name + "_Medium"
    parent.add_child(medium_detail)
    
    # Low detail version (just water surface and major docks)
    var low_detail = _create_low_detail_lake(scene_root, lake_data)
    low_detail.name = lake_root.name + "_Low"
    parent.add_child(low_detail)
    
    # Create LOD controller
    var lod_controller = preload("res://scripts/world/lod/lake_scene_lod.gd").new()
    lod_controller.setup(high_detail, medium_detail, low_detail, lake_center, lod_distance)
    
    parent.add_child(lod_controller)
    lod_group.append(lod_controller)
    _prop_lod_groups.append_array(lod_group)
ðŸŽ¯ Phase 6: Integration & Testing
6.1 WorldBuilder Integration
Update scripts/world/world_builder.gd:
func _register_default_components() -> void:
    # ... existing components ...
    _component_registry.register_component("lakes", preload("res://scripts/world/components/builtin/lakes_component.gd"))
    _component_registry.register_component("lake_scenes", preload("res://scripts/world/components/builtin/lake_scenes_component.gd"))
    
_default_components = [
    "heightmap",
    "lakes",
    "biomes",
    "ocean",
    "terrain_mesh",
    "lake_scenes",  # New component after terrain mesh
    "runway",
    # ... rest of components ...
]
6.2 Game Settings Integration
Update scripts/game/game.gd:
# Lake scene parameters
"lake_scene_probability": 0.6,
"lake_scene_types": ["basic", "recreational", "fishing", "harbor"],
"boat_density": 0.3,
"buoy_density": 2.5,
"dock_probability": 0.4,
"shore_detail_probability": 0.7,
"beach_probability": 0.3,
"lake_scene_lod_distance": 500.0,
ðŸŽ¯ Implementation Benefits
âœ… Comprehensive Feature Set
- 4 lake types: Basic, Recreational, Fishing, Harbor
- 4 boat types: Fishing, Sailboat, Speedboat, Pontoon
- 3 buoy types: Navigation, Marker, Racing
- 4 dock types: Fishing Pier, Boat Launch, Marina Dock, Swimming Dock
- Shore features: Beaches, Concession stands, Picnic areas, Umbrellas
- Harbor infrastructure: Breakwaters, Navigation lights, Harbor buildings
âœ… Performance Optimized
- LOD system with 3 detail levels
- Mesh and material caching for efficiency
- Configurable scene probability to control performance impact
- Occlusion culling integration
âœ… Extensible Architecture
- Factory pattern for easy addition of new lake/boat/dock types
- Data-driven configuration via .tres resource files
- Component-based pipeline integrates seamlessly with existing system
- Deterministic generation maintains consistency
âœ… Realistic Scene Composition
- Procedural boat positioning with realistic orientations
- Logical dock placement at suitable shore points
- Natural shore feature distribution
- Harbor layouts with proper breakwater and navigation aids

--------

ðŸŽ¯ Refined Lake Scene Generator Plan
Key Adjustments Based on Your Preferences:
1. Adjustable Lake Scene Percentage - Default to 100% (all lakes get scenes)
2. Stylized/Procedural Assets - Focus on generated meshes, no external assets
3. Static Scene Generation - Static positioning with architecture for future movement
4. Performance-First Approach - Efficient LOD and caching systems
ðŸ“‹ Updated Implementation Strategy
Phase 1: Core Infrastructure (Adjusted)
Updated LakesComponent Parameters:
func get_optional_params() -> Dictionary:
    return {
        # Existing basic params
        "lake_count": 8,
        "lake_min_radius": 160.0,
        "lake_max_radius": 520.0,
        
        # Lake scene generation (ADJUSTED)
        "lake_scene_percentage": 1.0,  # 100% default, adjustable 0.0-1.0
        "lake_scene_types": ["basic", "recreational", "fishing", "harbor"],
        "lake_type_weights": {"basic": 0.3, "recreational": 0.3, "fishing": 0.25, "harbor": 0.15},
        
        # Scene density controls
        "boat_density_per_lake": 0.4,      # Average boats per lake
        "buoy_density_per_radius": 2.0,    # Buoys per 100 units of radius
        "dock_probability": 0.5,           # 50% chance of docks per lake
        "shore_feature_probability": 0.7,  # 70% chance of shore features
        
        # Performance controls
        "max_boats_per_lake": 8,
        "max_buoys_per_lake": 20,
        "max_docks_per_lake": 3,
    }
Phase 2: Stylized Procedural Asset System
Enhanced Boat Generator with Stylized Designs:
class_name BoatGenerator
extends RefCounted
func _create_boat_mesh(boat_type: String, position: Vector3, rng: RandomNumberGenerator) -> Node3D:
    var boat_root = Node3D.new()
    boat_root.position = position
    boat_root.name = "Boat_" + boat_type
    
    match boat_type:
        "fishing":
            boat_root = _create_stylized_fishing_boat(boat_root, rng)
        "sailboat":
            boat_root = _create_stylized_sailboat(boat_root, rng)
        "speedboat":
            boat_root = _create_stylized_speedboat(boat_root, rng)
        "pontoon":
            boat_root = _create_stylized_pontoon(boat_root, rng)
    
    # Add movement-ready components (static for now)
    _add_movement_readiness(boat_root, boat_type)
    
    return boat_root
func _create_stylized_fishing_boat(parent: Node3D, rng: RandomNumberGenerator) -> Node3D:
    # Stylized hull with exaggerated fishing boat features
    var hull_mesh = _create_fishing_hull_mesh(rng)
    var hull_instance = MeshInstance3D.new()
    hull_instance.mesh = hull_mesh
    hull_instance.material_override = _create_stylized_boat_material("fishing")
    parent.add_child(hull_instance)
    
    # Stylized cabin
    var cabin_mesh = _create_stylized_fishing_cabin(rng)
    var cabin_instance = MeshInstance3D.new()
    cabin_instance.mesh = cabin_mesh
    cabin_instance.position = Vector3(0, 2.0, -2.0)
    cabin_instance.material_override = _create_stylized_cabin_material()
    parent.add_child(cabin_instance)
    
    # Fishing equipment (stylized)
    _add_stylized_fishing_gear(parent, rng)
    
    return parent
func _create_stylized_sailboat(parent: Node3D, rng: RandomNumberGenerator) -> Node3D:
    # Sleek stylized hull
    var hull_mesh = _create_sailboat_hull_mesh(rng)
    var hull_instance = MeshInstance3D.new()
    hull_instance.mesh = hull_mesh
    hull_instance.material_override = _create_stylized_boat_material("sailboat")
    parent.add_child(hull_instance)
    
    # Stylized mast and sail
    var mast_system = _create_stylized_mast_system(rng)
    mast_system.position = Vector3(0, 0, 0)
    parent.add_child(mast_system)
    
    return parent
func _add_movement_readiness(boat_root: Node3D, boat_type: String) -> void:
    # Add components for future boat movement (static for now)
    var movement_controller = Node3D.new()
    movement_controller.name = "MovementController"
    movement_controller.set_script(preload("res://scripts/world/boat/boat_movement_controller.gd"))
    movement_controller.boat_type = boat_type
    movement_controller.is_static = true  # Start as static
    boat_root.add_child(movement_controller)
Phase 3: Static Scene Generation with Movement Architecture
Lake Scene Factory with Movement Extensibility:
class_name LakeSceneFactory
extends RefCounted
func generate_lake_scene(ctx: WorldContext, lake_data: Dictionary, parent: Node3D, rng: RandomNumberGenerator, params: Dictionary) -> Node3D:
    var scene_root = Node3D.new()
    scene_root.name = "LakeScene_%d" % ctx.seed
    
    # Determine if this lake gets a scene based on percentage
    if rng.randf() > params.get("lake_scene_percentage", 1.0):
        lake_data["scene_type"] = "basic"
        _generate_basic_lake_water(scene_root, lake_data, rng)
        return scene_root
    
    var scene_type = _determine_scene_type(lake_data, params, rng)
    lake_data["scene_type"] = scene_type
    
    # Generate static scene with movement-ready architecture
    _generate_lake_water(scene_root, lake_data, scene_type, rng)
    _generate_static_shore_features(ctx, scene_root, lake_data, scene_type, rng)
    _generate_static_docks(ctx, scene_root, lake_data, scene_type, rng)
    _generate_static_boats_and_buoys(ctx, scene_root, lake_data, scene_type, rng)
    
    # Add scene-wide movement controller (disabled initially)
    _add_scene_movement_controller(scene_root, lake_data, scene_type)
    
    parent.add_child(scene_root)
    return scene_root
func _generate_static_boats_and_buoys(ctx: WorldContext, scene_root: Node3D, lake_data: Dictionary, scene_type: String, rng: RandomNumberGenerator) -> void:
    var boat_generator = BoatGenerator.new()
    var lake_center = lake_data.center
    var lake_radius = lake_data.radius
    var params = ctx.params
    
    # Calculate boat count based on density and lake type
    var boat_count = _calculate_boat_count(lake_radius, scene_type, params, rng)
    boat_count = min(boat_count, params.get("max_boats_per_lake", 8))
    
    for i in range(boat_count):
        var boat_type = _select_boat_type_for_scene(scene_type, rng)
        var boat_pos = _generate_static_boat_position(lake_center, lake_radius, rng)
        var boat = boat_generator.create_static_boat(boat_type, boat_pos, rng)
        
        # Store movement data for future use
        boat.set_meta("original_position", boat_pos)
        boat.set_meta("boat_type", boat_type)
        boat.set_meta("movement_pattern", _select_movement_pattern(boat_type, rng))
        
        scene_root.add_child(boat)
func _add_scene_movement_controller(scene_root: Node3D, lake_data: Dictionary, scene_type: String) -> void:
    var movement_controller = Node3D.new()
    movement_controller.name = "LakeSceneMovementController"
    movement_controller.set_script(preload("res://scripts/world/lake/lake_scene_movement_controller.gd"))
    
    # Configure for future movement
    movement_controller.is_enabled = false  # Start disabled
    movement_controller.lake_data = lake_data
    movement_controller.scene_type = scene_type
    movement_controller.boat_nodes = []  # Will be populated by boats
    
    scene_root.add_child(movement_controller)
Phase 4: Performance-Optimized LOD System
Enhanced LOD with Static Optimization:
class_name LakeScenesComponent
extends WorldComponentBase
func generate(world_root: Node3D, params: Dictionary, rng: RandomNumberGenerator) -> void:
    if ctx.lakes.is_empty():
        return
    
    var lake_scenes_layer = ctx.get_layer("LakeScenes")
    var lod_root = Node3D.new()
    lod_root.name = "LakeScenes_LOD"
    lake_scenes_layer.add_child(lod_root)
    
    # Performance-optimized LOD generation
    for lake_data in ctx.lakes:
        if not lake_data.has("scene_root"):
            continue
            
        var lake_scene = lake_data.scene_root as Node3D
        var lod_system = _create_optimized_lod_system(lod_root, lake_scene, lake_data, params)
        
        if lod_system != null:
            ctx.prop_lod_groups.append(lod_system)
func _create_optimized_lod_system(parent: Node3D, scene_root: Node3D, lake_data: Dictionary, params: Dictionary) -> Node3D:
    var lod_controller = preload("res://scripts/world/lod/static_lake_scene_lod.gd").new()
    
    # Create LOD levels optimized for static scenes
    var high_detail = _create_high_detail_static(scene_root, lake_data)
    var medium_detail = _create_medium_detail_static(scene_root, lake_data)
    var low_detail = _create_low_detail_static(scene_root, lake_data)
    
    lod_controller.setup_static_lod(
        high_detail, medium_detail, low_detail,
        lake_data.center,
        params.get("lake_scene_lod_distance", 500.0)
    )
    
    parent.add_child(lod_controller)
    return lod_controller
ðŸŽ¯ Key Implementation Files
Core Files to Create:
1. scripts/resources/lake_defs.gd - Resource definitions
2. scripts/world/generators/lake_scene_factory.gd - Main factory
3. scripts/world/generators/boat_generator.gd - Stylized boats
4. scripts/world/generators/dock_generator.gd - Stylized docks
5. scripts/world/generators/shore_feature_generator.gd - Beaches, etc.
6. scripts/world/components/builtin/lake_scenes_component.gd - LOD component
7. scripts/world/boat/boat_movement_controller.gd - Future movement (static)
8. scripts/world/lake/lake_scene_movement_controller.gd - Scene movement
Files to Modify:
1. scripts/world/components/builtin/lakes_component.gd - Enhanced lake generation
2. scripts/world/world_builder.gd - Component registration
3. scripts/game/game.gd - Settings parameters
4. resources/defs/lake_defs.tres - Configuration file

