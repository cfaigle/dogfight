  âœ¦ Detailed Plan to Improve Collision and Damage System in Dogfight: 1940

    Executive Summary

    Based on my analysis of the current collision and damage system, I've identified that while the
    foundational architecture exists, the visual/audio effects and building destruction systems are not fully
     implemented. The system has the right components but lacks proper integration between them.

    Current State Analysis

    1. Damage System Components
     - DamageManager (scripts/managers/damage_manager.gd): Centralized singleton managing all damage
       application
     - VisualAudioEffectsSystem (scripts/systems/visual_audio_effects_system.gd): Predefined effects but not
       connected to damage manager
     - DestructionStageSystem (scripts/systems/destruction_stage_system.gd): Logic for transitioning between
       destruction stages
     - BaseDamageableObject (scripts/objects/base_damageable_object.gd): Base class for damageable objects
     - BuildingDamageableObject (scripts/objects/building_damageable_object.gd): Building-specific damage
       handling

    2. Current Issues Identified
     - Visual and audio effects are defined but not triggered during damage events
     - _apply_visual_effects and _apply_audio_effects in DamageManager are stubbed with pass
     - Building destruction doesn't generate debris or physics effects
     - Sound effects are loaded but not played during damage/destruction
     - Collision detection between weapons and buildings is not properly implemented

    Detailed Implementation Plan

    Phase 1: Connect Visual and Audio Effects to Damage Manager

    1.1 Update DamageManager Methods
    File: scripts/managers/damage_manager.gd

    Current Code:

      1 ## Apply visual effects to an object
      2 func _apply_visual_effects(object, effects_config: Dictionary) -> void:
      3     # This would apply particle effects, material changes, etc.
      4     # Implementation depends on the specific object type
      5     pass
      6 
      7 ## Apply audio effects to an object
      8 func _apply_audio_effects(object, effects_config: Dictionary) -> void:
      9     # This would play sounds based on the damage/destruction
     10     # Implementation depends on the specific object type
     11     pass

    Updated Code:

      1 ## Apply visual effects to an object
      2 func _apply_visual_effects(object, effects_config: Dictionary) -> void:
      3     # Apply visual effects using the VisualAudioEffectsSystem
      4     var effects_system = preload("res://scripts/systems/visual_audio_effects_system.gd").new()
      5     var destruction_stage = get_destruction_stage(object)
      6     var object_set = get_object_set(object)
      7     effects_system.apply_visual_effects(object, destruction_stage, object_set, effects_config)
      8 
      9 ## Apply audio effects to an object
     10 func _apply_audio_effects(object, effects_config: Dictionary) -> void:
     11     # Apply audio effects using the VisualAudioEffectsSystem
     12     var effects_system = preload("res://scripts/systems/visual_audio_effects_system.gd").new()
     13     var destruction_stage = get_destruction_stage(object)
     14     var object_set = get_object_set(object)
     15     effects_system.apply_audio_effects(object, destruction_stage, object_set, effects_config)

    1.2 Update Destruction Stage System
    File: scripts/systems/destruction_stage_system.gd

    Update the placeholder methods:

      1 ## Spawn a particle effect at the object's location
      2 static func _spawn_particle_effect(object, effect_name: String) -> void:
      3     # Actual implementation to spawn particle effects
      4     var particle_scenes = {
      5         "smoke": preload("res://effects/particle_smoke.tscn"),
      6         "dust": preload("res://effects/particle_dust.tscn"),
      7         "sparks": preload("res://effects/particle_sparks.tscn"),
      8         "debris": preload("res://effects/particle_debris.tscn"),
      9         "wood_debris": preload("res://effects/particle_wood_debris.tscn"),
     10         "leaves": preload("res://effects/particle_leaves.tscn"),
     11         "bark_debris": preload("res://effects/particle_bark_debris.tscn")
     12     }
     13     
     14     if particle_scenes.has(effect_name):
     15         var effect_scene = particle_scenes[effect_name]
     16         if effect_scene:
     17             var effect_instance = effect_scene.instantiate()
     18             
     19             # Position the effect at the object's location
     20             effect_instance.global_position = object.global_position
     21             
     22             # Add to the scene
     23             var parent = object.get_parent()
     24             if parent:
     25                 parent.add_child(effect_instance)
     26             else:
     27                 var root = object.get_tree().root
     28                 root.add_child(effect_instance)
     29                 
     30             effect_instance.owner = parent if parent else object.get_tree().root
     31             
     32             # Auto-remove after lifetime
     33             var lifetime = 3.0  # Default lifetime
     34             if effect_instance.has_method("get_lifetime"):
     35                 lifetime = effect_instance.get_lifetime()
     36                 
     37             # Schedule removal
     38             var timer = Timer.new()
     39             timer.wait_time = lifetime
     40             timer.timeout.connect(func():
     41                 if is_instance_valid(effect_instance):
     42                     effect_instance.queue_free()
     43                 if is_instance_valid(timer):
     44                     timer.queue_free()
     45             )
     46             object.add_child(timer)
     47             timer.start()
     48 
     49 ## Play a sound effect at the object's location
     50 static func _play_sound_effect(object, sound_name: String) -> void:
     51     # Actual implementation to play sound effects
     52     var audio_effects = {
     53         "metal_impact": preload("res://sounds/metal_impact.wav"),
     54         "explosion": preload("res://sounds/explosion.wav"),
     55         "wood_crack": preload("res://sounds/wood_crack.wav"),
     56         "structure_collapse": preload("res://sounds/structure_collapse.wav"),
     57         "tree_crack": preload("res://sounds/tree_crack.wav"),
     58         "tree_fall": preload("res://sounds/tree_fall.wav")
     59     }
     60     
     61     if audio_effects.has(sound_name):
     62         var audio_stream = audio_effects[sound_name]
     63         if audio_stream:
     64             # Create an AudioStreamPlayer3D to play the sound at the object's location
     65             var audio_player = AudioStreamPlayer3D.new()
     66             audio_player.stream = audio_stream
     67             audio_player.global_position = object.global_position
     68             audio_player.unit_db = 5.0  # Adjust volume as needed
     69             audio_player.unit_size = 100.0  # Adjust audible range as needed
     70 
     71             # Add to the scene
     72             var parent = object.get_parent()
     73             if parent:
     74                 parent.add_child(audio_player)
     75             else:
     76                 var root = object.get_tree().root
     77                 root.add_child(audio_player)
     78                 
     79             audio_player.owner = parent if parent else object.get_tree().root
     80 
     81             # Play the sound
     82             audio_player.play()
     83 
     84             # Auto-remove after sound finishes
     85             audio_player.finished.connect(func():
     86                 if is_instance_valid(audio_player):
     87                     audio_player.queue_free()
     88             )

    Phase 2: Enhance Building Damage and Destruction

    2.1 Update BuildingDamageableObject
    File: scripts/objects/building_damageable_object.gd

    Enhance the `_on_destroyed` method:

       1 ## Called when the building is destroyed
       2 func _on_destroyed() -> void:
       3     # Apply destruction effects
       4     _apply_destroyed_effects()
       5 
       6     # Notify DamageManager
       7     if Engine.has_singleton("DamageManager"):
       8         var damage_manager = Engine.get_singleton("DamageManager")
       9         damage_manager.object_destroyed.emit(self)
      10 
      11     # Emit local signal
      12     destroyed.emit()
      13 
      14     # Generate debris based on building type
      15     _generate_building_debris()
      16 
      17     # Apply physics to building parts if needed
      18     _apply_physics_to_building_parts()
      19 
      20     # Fade out effect
      21     var tween = create_tween()
      22     tween.tween_method(func(val):
      23         if building_mesh and building_mesh.material_override:
      24             var mat = building_mesh.material_override
      25             mat.albedo_color = Color(mat.albedo_color.r, mat.albedo_color.g, mat.albedo_color.b, 
         val)
      26     , 1.0, 0.0, 2.0)
      27 
      28     # Queue for removal after effect completes
      29     await tween.finished
      30     queue_free()
      31 
      32 ## Generate debris when building is destroyed
      33 func _generate_building_debris() -> void:
      34     # Determine debris based on building type
      35     var debris_count = 0
      36     var debris_size_range = {"min": 0.5, "max": 2.0}
      37     
      38     match object_set:
      39         "Industrial":
      40             debris_count = randi_range(3, 8)
      41             debris_size_range = {"min": 0.8, "max": 3.0}
      42         "Residential":
      43             debris_count = randi_range(1, 4)
      44             debris_size_range = {"min": 0.5, "max": 1.5}
      45         "Natural":
      46             debris_count = randi_range(2, 6)
      47             debris_size_range = {"min": 0.3, "max": 1.0}
      48         _:
      49             debris_count = randi_range(2, 5)
      50             debris_size_range = {"min": 0.5, "max": 2.0}
      51     
      52     # Create debris objects
      53     for i in range(debris_count):
      54         _create_debris_piece(i, debris_size_range)
      55 
      56 ## Create a single debris piece
      57 func _create_debris_piece(index: int, size_range: Dictionary) -> void:
      58     # Create a simple debris object with physics
      59     var debris_body = RigidBody3D.new()
      60     debris_body.name = "DebrisPiece_%d" % index
      61     
      62     # Position debris near the building
      63     var offset = Vector3(
      64         randf_range(-2.0, 2.0),
      65         randf_range(0.5, 3.0),
      66         randf_range(-2.0, 2.0)
      67     )
      68     debris_body.global_position = global_position + offset
      69     
      70     # Create a simple shape for the debris
      71     var shape_size = Vector3(
      72         randf_range(size_range.min, size_range.max),
      73         randf_range(size_range.min, size_range.max),
      74         randf_range(size_range.min, size_range.max)
      75     )
      76     
      77     var collision_shape = CollisionShape3D.new()
      78     var box_shape = BoxShape3D.new()
      79     box_shape.size = shape_size
      80     collision_shape.shape = box_shape
      81     debris_body.add_child(collision_shape)
      82     collision_shape.owner = debris_body
      83     
      84     # Create a visual representation
      85     var mesh_instance = MeshInstance3D.new()
      86     var box_mesh = BoxMesh.new()
      87     box_mesh.size = shape_size
      88     mesh_instance.mesh = box_mesh
      89     
      90     # Apply material based on building type
      91     var material = StandardMaterial3D.new()
      92     match object_set:
      93         "Industrial":
      94             material.albedo_color = Color(0.4, 0.4, 0.4)  # Gray metal
      95         "Residential":
      96             material.albedo_color = Color(0.6, 0.5, 0.4)  # Brown wood/brick
      97         "Natural":
      98             material.albedo_color = Color(0.3, 0.6, 0.3)  # Green vegetation
      99         _:
     100             material.albedo_color = Color(0.5, 0.5, 0.5)  # Default gray
     101     
     102     mesh_instance.material_override = material
     103     debris_body.add_child(mesh_instance)
     104     mesh_instance.owner = debris_body
     105     
     106     # Add to the scene
     107     var parent = get_parent()
     108     if parent:
     109         parent.add_child(debris_body)
     110     else:
     111         get_tree().root.add_child(debris_body)
     112         
     113     debris_body.owner = parent if parent else get_tree().root
     114     
     115     # Apply initial impulse to make debris fly outward
     116     var direction = (Vector3(randf(), randf(), randf()) - Vector3(0.5, 0.5, 0.5)).normalized()
     117     var force = randf_range(5.0, 20.0)
     118     debris_body.apply_impulse(direction * force, Vector3.ZERO)
     119 
     120 ## Apply physics to building parts (if the building has multiple parts)
     121 func _apply_physics_to_building_parts() -> void:
     122     # This would iterate through child nodes that represent building parts
     123     # and convert them to physics objects if they meet certain criteria
     124     for child in get_children():
     125         if child is MeshInstance3D and child.name.to_lower().contains("part"):
     126             # Convert this part to a physics object
     127             _convert_part_to_physics(child)
     128 
     129 ## Convert a building part to a physics object
     130 func _convert_part_to_physics(part_mesh: MeshInstance3D) -> void:
     131     # Create a rigid body for this part
     132     var rigid_body = RigidBody3D.new()
     133     rigid_body.name = part_mesh.name + "_Physics"
     134     rigid_body.global_transform = part_mesh.global_transform
     135     
     136     # Copy the mesh
     137     var new_mesh_instance = MeshInstance3D.new()
     138     new_mesh_instance.mesh = part_mesh.mesh.duplicate()
     139     new_mesh_instance.material_override = part_mesh.material_override
     140     rigid_body.add_child(new_mesh_instance)
     141     new_mesh_instance.owner = rigid_body
     142     
     143     # Add collision shape
     144     var collision_shape = CollisionShape3D.new()
     145     var mesh_shape = ConcavePolygonShape3D.new()
     146     # Note: Creating a proper collision shape from mesh would require more complex logic
     147     # For now, we'll use a bounding box approximation
     148     var bbox = part_mesh.mesh.get_mesh_arrays()[ArrayMesh.ARRAY_VERTEX]
     149     var box_shape = BoxShape3D.new()
     150     box_shape.size = Vector3(2, 2, 2)  # Approximate size
     151     collision_shape.shape = box_shape
     152     rigid_body.add_child(collision_shape)
     153     collision_shape.owner = rigid_body
     154     
     155     # Add to scene
     156     var parent = get_parent()
     157     if parent:
     158         parent.add_child(rigid_body)
     159     else:
     160         get_tree().root.add_child(rigid_body)
     161         
     162     rigid_body.owner = parent if parent else get_tree().root
     163     
     164     # Apply an impulse to make it fly away
     165     var direction = (global_position - part_mesh.global_position).normalized()
     166     var force = randf_range(10.0, 30.0)
     167     rigid_body.apply_impulse(direction * force, Vector3.ZERO)
     168     
     169     # Remove the original part
     170     part_mesh.queue_free()

    Phase 3: Improve Sound System Integration

    3.1 Enhance Weapon-Building Collision Detection
    File: scripts/actors/weapons/gun.gd

    Update the `_apply_damage_to_collider` method:

      1 # Apply damage to a collider
      2 func _apply_damage_to_collider(collider: Node3D, damage: float) -> void:
      3     print("COLLISION DEBUG: Attempting to apply damage to: ", collider.name if collider.has_method(
        "name") else str(collider))
      4     
      5     # First, try walking up the parent chain to find a node with apply_damage
      6     var n = collider
      7     while n:
      8         print("COLLISION DEBUG: Checking node: ", n.name if n.has_method("name") else str(n), " for 
        apply_damage method")
      9         if n.has_method("apply_damage"):
     10             # Prefer DamageManager if present and compatible, otherwise call apply_damage directly.
     11             if Engine.has_singleton("DamageManager"):
     12                 var dm := Engine.get_singleton("DamageManager")
     13                 if dm and dm.has_method("apply_damage_to_object"):
     14                     print("COLLISION DEBUG: Found apply_damage on: ", n.name, " - applying damage via
        DamageManager")
     15                     dm.call("apply_damage_to_object", n, damage, "bullet")
     16                     
     17                     # Add visual effects for bullet hitting building
     18                     _create_bullet_hit_effects(collider.global_position)
     19                     
     20                     return
     21             n.call("apply_damage", damage)
     22             
     23             # Add visual effects for bullet hitting building
     24             _create_bullet_hit_effects(collider.global_position)
     25             
     26             return
     27         n = n.get_parent()
     28 
     29     # If no apply_damage method found in parent chain, check children for damageable components
     30     var damageable_found = _find_damageable_child(collider)
     31     if damageable_found:
     32         if Engine.has_singleton("DamageManager"):
     33             var dm := Engine.get_singleton("DamageManager")
     34             if dm and dm.has_method("apply_damage_to_object"):
     35                 print("COLLISION DEBUG: Found damageable child: ", damageable_found.name, " - 
        applying damage via DamageManager")
     36                 dm.call("apply_damage_to_object", damageable_found, damage, "bullet")
     37                 
     38                 # Add visual effects for bullet hitting building
     39                 _create_bullet_hit_effects(collider.global_position)
     40                 
     41                 return
     42         damageable_found.call("apply_damage", damage)
     43         
     44         # Add visual effects for bullet hitting building
     45         _create_bullet_hit_effects(collider.global_position)
     46         
     47         return
     48 
     49     print("COLLISION DEBUG: No apply_damage method found in parent chain or children")
     50     print("DEBUG: No node with apply_damage method found in parent chain or children")
     51 
     52 ## Create visual effects for bullet hitting a surface
     53 func _create_bullet_hit_effects(hit_position: Vector3) -> void:
     54     # Create a small particle effect for bullet hit
     55     var hit_effect = preload("res://effects/particle_sparks.tscn").instantiate()
     56     hit_effect.global_position = hit_position
     57     var parent = get_parent()
     58     if parent:
     59         parent.add_child(hit_effect)
     60     else:
     61         get_tree().root.add_child(hit_effect)
     62         
     63     hit_effect.owner = parent if parent else get_tree().root
     64     
     65     # Auto-remove after short time
     66     var timer = Timer.new()
     67     timer.wait_time = 0.5
     68     timer.timeout.connect(func():
     69         if is_instance_valid(hit_effect):
     70             hit_effect.queue_free()
     71         if is_instance_valid(timer):
     72             timer.queue_free()
     73     )
     74     if parent:
     75         parent.add_child(timer)
     76     else:
     77         get_tree().root.add_child(timer)
     78     timer.owner = parent if parent else get_tree().root
     79     timer.start()

    3.2 Update Missile Collision Handling
    File: scripts/actors/weapons/missile.gd

    Enhance the `_hit` method:

      1 func _hit(obj: Object) -> void:
      2     # Apply damage to the hit object
      3     _apply_damage_to_collider(obj, damage)
      4     
      5     # Create explosion effects at the hit position
      6     _create_explosion_effects(global_position)
      7     
      8     # Explode the missile
      9     _explode()
     10 
     11 ## Create explosion effects at the given position
     12 func _create_explosion_effects(explosion_position: Vector3) -> void:
     13     # Create visual explosion
     14     var explosion_visual = preload("res://effects/particle_explosion.tscn").instantiate()
     15     if explosion_visual:
     16         explosion_visual.global_position = explosion_position
     17         var parent = get_parent()
     18         if parent:
     19             parent.add_child(explosion_visual)
     20         else:
     21             get_tree().root.add_child(explosion_visual)
     22             
     23         explosion_visual.owner = parent if parent else get_tree().root
     24         
     25         # Auto-remove after explosion completes
     26         var timer = Timer.new()
     27         timer.wait_time = 2.0
     28         timer.timeout.connect(func():
     29             if is_instance_valid(explosion_visual):
     30                 explosion_visual.queue_free()
     31             if is_instance_valid(timer):
     32                 timer.queue_free()
     33         )
     34         if parent:
     35             parent.add_child(timer)
     36         else:
     37             get_tree().root.add_child(timer)
     38         timer.owner = parent if parent else get_tree().root
     39         timer.start()
     40     
     41     # Play explosion sound
     42     var audio_player = AudioStreamPlayer3D.new()
     43     audio_player.stream = preload("res://sounds/explosion.wav")
     44     audio_player.global_position = explosion_position
     45     audio_player.unit_db = 8.0
     46     audio_player.unit_size = 150.0
     47     
     48     var parent = get_parent()
     49     if parent:
     50         parent.add_child(audio_player)
     51     else:
     52         get_tree().root.add_child(audio_player)
     53         
     54     audio_player.owner = parent if parent else get_tree().root
     55     audio_player.play()
     56     
     57     # Auto-remove after sound completes
     58     audio_player.finished.connect(func():
     59         if is_instance_valid(audio_player):
     60             audio_player.queue_free()
     61     )

    Phase 4: Add Physics-Based Destruction

    4.1 Update Collision Manager for Building Collisions
    File: scripts/managers/collision_manager.gd

    Add method to handle weapon-building collisions:

      1 ## Handle collision between a weapon and a building
      2 func handle_weapon_building_collision(weapon: Node, building: Node) -> void:
      3     # This method would be called when a weapon collides with a building
      4     # It would apply damage to the building and handle the collision effects
      5     if building.has_method("apply_damage"):
      6         # Apply damage based on weapon type
      7         var damage_amount = 10.0  # Default damage
      8         if weapon.has_method("get_damage"):
      9             damage_amount = weapon.get_damage()
     10         
     11         building.apply_damage(damage_amount)
     12     else:
     13         print("DEBUG: Building does not have apply_damage method: ", building.name)

    Phase 5: Testing and Integration

    5.1 Create Test Scenarios
     - Test gun damage on buildings with different object sets
     - Test missile damage on buildings
     - Verify visual and audio effects trigger properly
     - Ensure debris generation works correctly
     - Test performance impact of multiple simultaneous destructions

    5.2 Update Configuration Files
     - Ensure resources/configs/object_sets_config.tres has proper values for visual and audio effects
     - Verify sound files exist in the sounds/ directory
     - Confirm particle effect scenes are properly configured

    Implementation Order

     1. Phase 1: Update DamageManager to connect visual/audio effects
     2. Phase 2: Enhance BuildingDamageableObject for proper destruction
     3. Phase 3: Update weapon collision handling
     4. Phase 4: Add physics-based destruction
     5. Phase 5: Test and refine the system


